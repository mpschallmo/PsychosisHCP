#!/bin/tcsh -xef
# authors mps, tes, cao, pcb
# N.B. paths have been removed, labed by ****, must be replaced to match local directories

echo "auto-generated by afni_proc.py, Tue Feb 27 13:07:01 2018"
echo "(version 5.11, December 29, 2016)"
echo "execution started: `date`"

# execute via : 
#   tcsh -xef proc_unwarp_GLM.csh |& tee output_proc.txt

# =========================== auto BLOCK4: setup ============================
# script setup

# take note of the AFNI version
afni -ver

# check that the current AFNI version is recent enough
afni_history -check_date 23 Sep 2016
if ( $status ) then
    echo "** this script requires newer AFNI binaries (than 23 Sep 2016)"
    echo "   (consider: @update.afni.binaries -defaults)"
    exit
endif

# the user may specify a single subject to run with
if ( $#argv > 0 ) then
    set subj = $argv[1]
    set prf = $argv[2]
    set protocol = $argv[3]
else
    echo "Please set subject, pRF count, and protocol letter"
    exit
endif

# assign 7T QA dir
set QA7T_dir = '**** PATH TO THE QA DIR GOES HERE ****'

# assign output directory name
set output_dir = {$QA7T_dir}/{$subj}/results_$protocol

# verify that the results directory does not yet exist
if ( -d $output_dir ) then
    echo output dir "$output_dir" already exists
    exit
endif

# set list of runs
if ($prf == 2) then 
     set runs = (`count -digits 2 1 7`)
else
     set runs = (`count -digits 2 1 6`)
endif

# create results and stimuli directories
mkdir $output_dir
mkdir $output_dir/stimuli
mkdir $output_dir/files_ACF
mkdir $output_dir/files_ClustSim

#check if surface volume exists 
if (-d **** PATH TO 3T anatomy ****/HCP-3.22.0/PHCP$subj/T1w/PHCP$subj/SUMA ) then
     ln -s                                                                                             \
    **** PATH TO 3T anatomy ****/HCP-3.22.0/PHCP$subj/T1w/PHCP$subj/SUMA/anat_SurfVol.nii \
    $output_dir/
else 

#create surface volume
     @SUMA_Make_Spec_FS -fspath **** PATH TO 3T anatomy ****/HCP-3.22.0/PHCP$subj/T1w/PHCP$subj -sid anat

     3dcopy **** PATH TO 3T anatomy ****/HCP-3.22.0/PHCP$subj/T1w/PHCP$subj/SUMA/anat_SurfVol+orig. **** PATH TO 3T anatomy ****/HCP-3.22.0/PHCP$subj/T1w/PHCP$subj/SUMA/anat_SurfVol.nii

# link anatomy to results dir
     ln -s                                                                                             \
    **** PATH TO 3T anatomy ****/HCP-3.22.0/PHCP$subj/T1w/PHCP$subj/SUMA/anat_SurfVol.nii \
    $output_dir/
endif

3dSkullStrip -prefix $output_dir/anat_SurfVol_ns -input $output_dir/anat_SurfVol.nii -orig_vol
3dUnifize -prefix $output_dir/anat_SurfVol_ns_uni -input $output_dir/anat_SurfVol_ns+orig -GM

# will extract automatic -blip_forward_dset in tcat BLOCK4, below

set data_dir = **** PATH TO 7T unprocessed .nii.gz data ****

# copy external -blip_reverse_dset dataset
3dTcat -prefix $output_dir/blip_reverse \
    {$data_dir}/BOLDoppPEAP.nii.gz

# ============================ auto BLOCK4: tcat ============================
# apply 3dTcat to copy input dsets to results dir, while
# removing the first 0 TRs
if ($prf == 2) then
     3dTcat -prefix $output_dir/pb00.$subj.r01.tcat \
    {$data_dir}/BOLDPRF1AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r02.tcat \
    {$data_dir}/BOLDCSStask1AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r03.tcat \
    {$data_dir}/BOLDCSStask2AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r04.tcat \
    {$data_dir}/BOLDCSStask3AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r05.tcat \
    {$data_dir}/BOLDCOPtask1AP.nii'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r06.tcat \
    {$data_dir}/BOLDCOPtask2AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r07.tcat \
    {$data_dir}/BOLDPRF2AP.nii.gz'[0..$]'

     # and make note of repetitions (TRs) per run
     set tr_counts = ( 324 297 297 297 468 312 324 )
else
     3dTcat -prefix $output_dir/pb00.$subj.r01.tcat \
    {$data_dir}/BOLDPRF1AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r02.tcat \
    {$data_dir}/BOLDCSStask1AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r03.tcat \
    {$data_dir}/BOLDCSStask2AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r04.tcat \
    {$data_dir}/BOLDCSStask3AP.nii.gz'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r05.tcat \
    {$data_dir}/BOLDCOPtask1AP.nii'[0..$]'
     3dTcat -prefix $output_dir/pb00.$subj.r06.tcat \
    {$data_dir}/BOLDCOPtask2AP.nii.gz'[0..$]'

     # and make note of repetitions (TRs) per run
     set tr_counts = ( 324 297 297 297 468 312 )
endif
# -------------------------------------------------------
# enter the results directory (can begin processing data)
cd $output_dir

# ========================== auto BLOCK4: outcount ==========================
# data check: compute outlier fraction for each volume
touch out.pre_ss_warn.txt
foreach run ( $runs )
    3dToutcount -automask -fraction -polort 4 -legendre                     \
                pb00.$subj.r$run.tcat+orig > outcount.r$run.1D

    # outliers at TR 0 might suggest pre-steady state TRs
    if ( `1deval -a outcount.r$run.1D"{0}" -expr "step(a-0.4)"` ) then
        echo "** TR #0 outliers: possible pre-steady state TRs in run $run" \
            >> out.pre_ss_warn.txt
    endif
end

# catenate outlier counts into a single time series
cat outcount.r*.1D > outcount_rall.1D

# ================================= tshift =================================
# time shift data so all slice timing is the same 
foreach run ( $runs )
    3dTshift -tzero 0 -quintic -prefix pb01.$subj.r$run.tshift pb00.$subj.r$run.tcat+orig
end

# can't do 3dTshift for oppPE, because AFNI requires minimum 5 TRs...

# ================================= grad unwarp ==================================

3dbucket -prefix gu_base pb01.$subj.r01.tshift+orig"[2]"
3dcopy gu_base+orig gu_base.nii.gz

gradient_unwarp.py gu_base.nii.gz grad_unwarp.nii.gz siemens -g                 \
    **** PATH TO GRADIENT COEFF FILE ****/7TAScoeff_fromScanner_12Jan2018.grad -n

python **** PATH TO CODE ****/makeFullWarpRel.py fullWarp_abs.nii.gz

foreach run ($runs)
    3dNwarpApply                             \
        -source pb01.$subj.r$run.tshift+orig \
        -nwarp "fullWarp_rel.nii.gz"         \
        -prefix rm.$subj.r$run.gu+orig
end

3dNwarpApply                             \
    -source blip_reverse+orig            \
    -nwarp "fullWarp_rel.nii.gz"         \
    -prefix rm.blip_reverse.gu+orig


# ================================= volreg =================================
# align each dset to base volume, blip warp, align to anat
# (final warp input is same as blip input)

# extract volreg registration base
3dbucket -prefix vr_base rm.$subj.r01.gu+orig"[2]"

# register and warp
foreach run ( $runs )
    # register each volume to the base
    3dvolreg -verbose -zpad 1 -base vr_base+orig                          \
             -1Dfile dfile.r$run.1D -prefix rm.epi.volreg.r$run           \
             -cubic                                                       \
             -1Dmatrix_save mat.r$run.vr.aff12.1D                         \
             rm.$subj.r$run.gu+orig
end

# might as well do motion correction for opp PE while we're at it, hope we don't need it!
3dvolreg -verbose -zpad 1                \
         -prefix blip_reverse.vr+orig \
         -cubic                          \
         rm.blip_reverse.gu+orig


# make a single file of registration params
cat dfile.r*.1D > dfile_rall.1D


# ================================== blip ==================================
# apply blip up/down non-linear alignment to EPI

# -------------------------------------------------------
# extract initial volumes as automatic -blip_forward_dset
# use the volreg file above here for blip forward
3dTcat -prefix blip_forward.vr rm.epi.volreg.r01+orig"[0..2]"

# create median datasets from forward and reverse time series
3dTstat -median -prefix rm.blip.med.fwd blip_forward.vr+orig
3dTstat -median -prefix rm.blip.med.rev blip_reverse.vr+orig

# automask the median datasets 
3dAutomask -apply_prefix rm.blip.med.masked.fwd rm.blip.med.fwd+orig
3dAutomask -apply_prefix rm.blip.med.masked.rev rm.blip.med.rev+orig

# compute the midpoint warp between the median datasets
3dQwarp -plusminus -pmNAMES Rev For                           \
        -pblur 0.05 0.05 -blur -1 -1                          \
        -noweight -minpatch 9                                 \
        -source rm.blip.med.masked.rev+orig                   \
        -base   rm.blip.med.masked.fwd+orig                   \
        -prefix blip_warp



# --------------------------------

# ================================= align ==================================
# create align_base 

3dNwarpApply                         \
    -source vr_base+orig             \
    -nwarp "blip_warp_For_WARP+orig" \
    -prefix align_base


# for e2a: compute anat alignment transformation to EPI registration base
# (new anat will be intermediate, stripped, anat_SurfVol_ns+orig)
align_epi_anat.py -epi2anat -anat anat_SurfVol_ns+orig \
        -suffix _al_junk                               \
        -epi align_base+orig                           \
        -epi_base 0                                    \
        -epi_strip 3dAutomask                          \
        -ginormous_move                                \
        -volreg off                                    \
        -tshift off                                    \
        -cost lpc+ZZ                                   \
        -anat_has_skull no

foreach run ($runs)

    # apply catenated xform: blip/volreg/epi2anat/NLtlrc
    # then apply non-linear standard-space warp

    3dNwarpApply                                                                                                   \
        -source pb01.$subj.r$run.tshift+orig                                                                       \
        -master anat_SurfVol_ns+orig                                                                               \
        -newgrid 1.6                                                                                               \
        -nwarp "align_base_al_junk_mat.aff12.1D blip_warp_For_WARP+orig mat.r$run.vr.aff12.1D fullWarp_rel.nii.gz" \
        -prefix pb02.$subj.r$run.volreg+orig

    3dZeropad -overwrite -R -15 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -L -15 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -A -15 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -P -15 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -S -40 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig 
    3dZeropad -overwrite -I -20 -prefix pb02.$subj.r$run.volreg+orig pb02.$subj.r$run.volreg+orig
    
    3dcalc -overwrite -prefix pb02.$subj.r$run.volreg+orig -a pb02.$subj.r$run.volreg+orig -expr 'a' -datum short
     
    # create an all-1 dataset to mask the extents of the warp
     3dcalc -overwrite -a pb02.$subj.r$run.volreg+orig -expr 'step(a)'               \
           -prefix rm.epi.all1


# make an extents intersection mask of this run
    3dTstat -min -prefix rm.epi.min.r$run rm.epi.all1+orig
end
# ----------------------------------------


# create the extents mask: mask_epi_extents+orig
# (this is a mask of voxels that have valid data at every TR)
3dMean -datum short -prefix rm.epi.mean rm.epi.min.r*.HEAD 
3dcalc -a rm.epi.mean+orig -expr 'step(a-0.999)' -prefix mask_epi_extents

# and apply the extents mask to the EPI data 
# (delete any time series with missing data)
foreach run ( $runs )
    3dcalc -a pb02.$subj.r$run.volreg+orig -b mask_epi_extents+orig           \
           -expr 'a*b' -prefix pb03.$subj.r$run.masked
end

# warp the volreg base EPI dataset to make a final version
cat_matvec -ONELINE anat_SurfVol_ns_al_junk_e2a_only_mat.aff12.1D -I  >               \
    mat.basewarp.aff12.1D

3dAllineate -base anat_SurfVol_ns+orig                                    \
            -input vr_base+orig                                           \
            -1Dmatrix_apply mat.basewarp.aff12.1D                         \
            -mast_dxyz 1.6                                                \
            -prefix final_epi_vr_base

# create an anat_final dataset, aligned with stats
3dcopy anat_SurfVol_ns+orig anat_final.$subj

# record final registration costs
3dAllineate -base final_epi_vr_base+orig -allcostX                        \
            -input anat_final.$subj+orig |& tee out.allcostX.txt

# -----------------------------------------
# warp anat follower datasets (identity: resample)



# ================================== blur ==================================
# blur each volume of each run
foreach run ( $runs )
    3dmerge -1blur_fwhm 2.0 -doall -prefix pb04.$subj.r$run.blur \
            pb03.$subj.r$run.masked+orig
end

# ================================== mask ==================================
# create 'full_mask' dataset (union mask)
foreach run ( $runs )
    3dAutomask -dilate 1 -prefix rm.mask_r$run pb04.$subj.r$run.blur+orig
end

# create union of inputs, output type is byte
3dmask_tool -inputs rm.mask_r*+orig.HEAD -union -prefix full_mask.$subj

# ---- create subject anatomy mask, mask_anat.$subj+orig ----
#      (resampled from aligned anat)
3dresample -master full_mask.$subj+orig -input anat_SurfVol_ns_uni+orig  \
           -prefix rm.resam.anat

# convert to binary anat mask; fill gaps and holes
3dmask_tool -dilate_input 5 -5 -fill_holes -input rm.resam.anat+orig \
            -prefix mask_anat.$subj

# compute overlaps between anat and EPI masks
3dABoverlap -no_automask full_mask.$subj+orig mask_anat.$subj+orig   \
            |& tee out.mask_ae_overlap.txt

# note Dice coefficient of masks, as well
3ddot -dodice full_mask.$subj+orig mask_anat.$subj+orig              \
      |& tee out.mask_ae_dice.txt

# ================================= scale ==================================
# scale each voxel time series to have a mean of 100
# (be sure no negatives creep in)
# (subject to a range of [0,200])
foreach run ( $runs )
    3dTstat -prefix rm.mean_r$run pb04.$subj.r$run.blur+orig
    3dcalc -a pb04.$subj.r$run.blur+orig -b rm.mean_r$run+orig \
           -c mask_epi_extents+orig                            \
           -expr 'c * min(200, a/b*100)*step(a)*step(b)'       \
           -prefix pb05.$subj.r$run.scale
end

# ================================ regress =================================

# wipe regressors if they're already there...
set behaviorDir = **** PATH TO BEHAVIOR DATA DIR ****/behavioral_data_{$protocol}

if ( -d {$behaviorDir}/afni ) then
    echo "Warning: wiping $behaviorDir/afni and re-making..."
    rm -fr {$behaviorDir}/afni
endif
if ( -d {$behaviorDir}/fsl ) then
    echo "Warning: wiping $behaviorDir/fsl and re-making..."
    rm -fr {$behaviorDir}/fsl
endif

foreach which_task ( 'prf' 'css' 'cop' )

    if ( ($which_task == 'prf') && ($prf == 2) ) then
        set use_runs = ( 1 7 )
        set idx_runs = ( 1 2 )
        set n_TRs = ( 324 324 )
        set scale_list = 'pb05.'{$subj}'.r01.scale+orig.HEAD pb05.'{$subj}'.r07.scale+orig.HEAD'
        set tcat_list = 'pb00.'{$subj}'.r01.tcat+orig.HEAD pb00.'{$subj}'.r07.tcat+orig.HEAD'
        set task_name_uppercase = 'pRF'
        set n_goforit = 3
        # allow for 3 errors / warnings, which is how many we get for pRF because the auditory task timing is not independent enough...
    else if ( ($which_task == 'prf') && ($prf == 1) ) then
        set use_runs = ( 1 )
        set idx_runs = ( 1 )
        set n_TRs = ( 324 )
        set scale_list = 'pb05.'{$subj}'.r01.scale+orig.HEAD'
        set tcat_list = 'pb00.'{$subj}'.r01.tcat+orig.HEAD'
        set task_name_uppercase = 'pRF'
        set n_goforit = 3
                # allow for 3 errors / warnings, which is how many we get for pRF because the auditory task timing is not independent enough...
    else if ($which_task == 'css') then
        set use_runs = ( 2 3 4 )
        set idx_runs = ( 1 2 3 )
        set n_TRs = ( 297 297 297 )
        set scale_list = 'pb05.'{$subj}'.r02.scale+orig.HEAD pb05.'{$subj}'.r03.scale+orig.HEAD pb05.'{$subj}'.r04.scale+orig.HEAD'
        set tcat_list = 'pb00.'{$subj}'.r02.tcat+orig.HEAD pb00.'{$subj}'.r03.tcat+orig.HEAD pb00.'{$subj}'.r04.tcat+orig.HEAD'
        set task_name_uppercase = 'CSS'
        set n_goforit = 0
    else if ($which_task == 'cop') then
        set use_runs = ( 5 6 )
        set idx_runs = ( 1 2 )
        set n_TRs = ( 468 312 )
        set scale_list = 'pb05.'{$subj}'.r05.scale+orig.HEAD pb05.'{$subj}'.r06.scale+orig.HEAD'
        set tcat_list = 'pb00.'{$subj}'.r05.tcat+orig.HEAD pb00.'{$subj}'.r06.tcat+orig.HEAD'
        set task_name_uppercase = 'COP'
        set n_goforit = 0
    endif

    touch dfile_{$which_task}.1D
    touch outcount_{$which_task}.1D

    foreach which_runs ( $use_runs )
        cat dfile.r0{$which_runs}.1D >> dfile_{$which_task}.1D
        cat outcount.r0{$which_runs}.1D >> outcount_{$which_task}.1D
    end

# compute de-meaned motion parameters (for use in regression)
    1d_tool.py -infile dfile_{$which_task}.1D -set_run_lengths  $n_TRs \
        -demean -write motion_demean_{$which_task}.1D

# compute motion parameter derivatives (just to have)
     1d_tool.py -infile dfile_{$which_task}.1D -set_run_lengths  $n_TRs \
           -derivative -demean -write motion_deriv_{$which_task}.1D

# create censor file motion_${subj}_censor.1D, for censoring motion 
     1d_tool.py -infile dfile_{$which_task}.1D -set_run_lengths  $n_TRs \
        -show_censor_count -censor_prev_TR                                  \
        -censor_motion 0.5 motion_${subj}_{$which_task}

    # note TRs that were not censored
    set ktrs = `1d_tool.py -infile motion_${subj}_{$which_task}_censor.1D         \
                           -show_trs_uncensored encoded`

# add regressors
    set codePath = **** PATH TO CODE ****/collect_pHCP_regressors_mps.py 
    python {$codePath} {$subj} {$task_name_uppercase} {$protocol}

    set regressorDir = {$behaviorDir}/afni/

    if ( ($which_task == 'prf') && ($prf == 2) ) then
        cat {$regressorDir}prf*_animal_bodies.txt > {$regressorDir}all_prf_animal_bodies.txt
        cat {$regressorDir}prf*_animal_faces.txt > {$regressorDir}all_prf_animal_faces.txt
        cat {$regressorDir}prf*_human_bodies.txt > {$regressorDir}all_prf_human_bodies.txt
        cat {$regressorDir}prf*_human_faces.txt > {$regressorDir}all_prf_human_faces.txt
        cat {$regressorDir}prf*_noise.txt > {$regressorDir}all_prf_noise.txt
        cat {$regressorDir}prf*_objects.txt > {$regressorDir}all_prf_objects.txt
        cat {$regressorDir}prf*_food.txt > {$regressorDir}all_prf_food.txt
        cat {$regressorDir}prf*_places.txt > {$regressorDir}all_prf_places.txt
        cat {$regressorDir}prf*_2HzVisual.txt > {$regressorDir}all_prf_2HzVisual.txt
        cat {$regressorDir}prf*_12HzVisual.txt > {$regressorDir}all_prf_12HzVisual.txt
        cat {$regressorDir}prf*_vfLLquad.txt > {$regressorDir}all_prf_vfLLquad.txt
        cat {$regressorDir}prf*_vfLRquad.txt > {$regressorDir}all_prf_vfLRquad.txt
        cat {$regressorDir}prf*_vfULquad.txt > {$regressorDir}all_prf_vfULquad.txt
        cat {$regressorDir}prf*_vfURquad.txt > {$regressorDir}all_prf_vfURquad.txt
        cat {$regressorDir}prf*_fovea.txt > {$regressorDir}all_prf_fovea.txt
        cat {$regressorDir}prf*_left_fingers.txt > {$regressorDir}all_prf_left_fingers.txt
        cat {$regressorDir}prf*_left_toes.txt > {$regressorDir}all_prf_left_toes.txt
        cat {$regressorDir}prf*_right_fingers.txt > {$regressorDir}all_prf_right_fingers.txt
        cat {$regressorDir}prf*_right_toes.txt > {$regressorDir}all_prf_right_toes.txt
        cat {$regressorDir}prf*_tongue.txt > {$regressorDir}all_prf_tongue.txt
        cat {$regressorDir}prf*_250HzTone.txt > {$regressorDir}all_prf_250HzTone.txt
        cat {$regressorDir}prf*_315HzTone.txt > {$regressorDir}all_prf_315HzTone.txt
        cat {$regressorDir}prf*_400HzTone.txt > {$regressorDir}all_prf_400HzTone.txt
        cat {$regressorDir}prf*_500HzTone.txt > {$regressorDir}all_prf_500HzTone.txt
        cat {$regressorDir}prf*_630HzTone.txt > {$regressorDir}all_prf_630HzTone.txt
        cat {$regressorDir}prf*_800HzTone.txt > {$regressorDir}all_prf_800HzTone.txt
        cat {$regressorDir}prf*_1000HzTone.txt > {$regressorDir}all_prf_1000HzTone.txt
        cat {$regressorDir}prf*_1250HzTone.txt > {$regressorDir}all_prf_1250HzTone.txt
        cat {$regressorDir}prf*_1600HzTone.txt > {$regressorDir}all_prf_1600HzTone.txt
        cat {$regressorDir}prf*_2000HzTone.txt > {$regressorDir}all_prf_2000HzTone.txt
        cat {$regressorDir}prf*_2500HzTone.txt > {$regressorDir}all_prf_2500HzTone.txt
        cat {$regressorDir}prf*_3150HzTone.txt > {$regressorDir}all_prf_3150HzTone.txt
        cat {$regressorDir}prf*_4000HzTone.txt > {$regressorDir}all_prf_4000HzTone.txt

        set n_cond = 33

        set stim_file_reg = "-stim_times 1 "{$regressorDir}"all_prf_vfLLquad.txt GAM -stim_label 1 LLquad -stim_times 2 "{$regressorDir}"all_prf_vfLRquad.txt GAM -stim_label 2 LRquad -stim_times 3 "{$regressorDir}"all_prf_vfULquad.txt GAM -stim_label 3 ULquad -stim_times 4 "{$regressorDir}"all_prf_vfURquad.txt GAM -stim_label 4 URquad -stim_times 5 "{$regressorDir}"all_prf_fovea.txt GAM -stim_label 5 fovea -stim_times 6 "{$regressorDir}"all_prf_left_fingers.txt 'BLOCK4(13,1)' -stim_label 6 LeftFinger -stim_times 7 "{$regressorDir}"all_prf_left_toes.txt 'BLOCK4(13,1)' -stim_label 7 LeftToe -stim_times 8 "{$regressorDir}"all_prf_right_fingers.txt 'BLOCK4(13,1)' -stim_label 8 RightFinger -stim_times 9 "{$regressorDir}"all_prf_right_toes.txt 'BLOCK4(13,1)' -stim_label 9 RightToe -stim_times 10 "{$regressorDir}"all_prf_tongue.txt 'BLOCK4(13,1)' -stim_label 10 Tongue -stim_times 11 "{$regressorDir}"all_prf_250HzTone.txt GAM -stim_label 11 250HzTone -stim_times 12 "{$regressorDir}"all_prf_315HzTone.txt GAM -stim_label 12 315HzTone -stim_times 13 "{$regressorDir}"all_prf_400HzTone.txt GAM -stim_label 13 400HzTone -stim_times 14 "{$regressorDir}"all_prf_500HzTone.txt GAM -stim_label 14 500HzTone -stim_times 15 "{$regressorDir}"all_prf_630HzTone.txt GAM -stim_label 15 630HzTone -stim_times 16 "{$regressorDir}"all_prf_800HzTone.txt GAM -stim_label 16 800HzTone -stim_times 17 "{$regressorDir}"all_prf_1000HzTone.txt GAM -stim_label 17 1000HzTone -stim_times 18 "{$regressorDir}"all_prf_1250HzTone.txt GAM -stim_label 18 1250HzTone -stim_times 19 "{$regressorDir}"all_prf_1600HzTone.txt GAM -stim_label 19 1600HzTone -stim_times 20 "{$regressorDir}"all_prf_2000HzTone.txt GAM -stim_label 20 2000HzTone -stim_times 21 "{$regressorDir}"all_prf_2500HzTone.txt GAM -stim_label 21 2500HzTone -stim_times 22 "{$regressorDir}"all_prf_3150HzTone.txt GAM -stim_label 22 3150HzTone -stim_times 23 "{$regressorDir}"all_prf_4000HzTone.txt GAM -stim_label 23 4000HzTone -stim_times 24 "{$regressorDir}"all_prf_human_faces.txt 'BLOCK4(16, 1)' -stim_label 24 human_faces -stim_times 25 "{$regressorDir}"all_prf_animal_faces.txt 'BLOCK4(16, 1)' -stim_label 25 animal_faces -stim_times 26 "{$regressorDir}"all_prf_human_bodies.txt 'BLOCK4(16, 1)' -stim_label 26 human_bodies -stim_times 27 "{$regressorDir}"all_prf_animal_bodies.txt 'BLOCK4(16, 1)' -stim_label 27 animal_bodies -stim_times 28 "{$regressorDir}"all_prf_food.txt 'BLOCK4(16, 1)' -stim_label 28 food -stim_times 29 "{$regressorDir}"all_prf_objects.txt 'BLOCK4(16, 1)' -stim_label 29 objects -stim_times 30 "{$regressorDir}"all_prf_places.txt 'BLOCK4(16, 1)' -stim_label 30 places -stim_times 31 "{$regressorDir}"all_prf_noise.txt 'BLOCK4(16, 1)' -stim_label 31 noise -stim_times 32 "{$regressorDir}"all_prf_2HzVisual.txt 'BLOCK4(16, 1)' -stim_label 32 tf2Hz -stim_times 33 "{$regressorDir}"all_prf_12HzVisual.txt 'BLOCK4(16, 1)' -stim_label 33 tf12Hz"
        set glt_reg = "-gltsym 'SYM: +0.5*food +0.5*objects -noise' -glt_label 1 obj_food-noise -gltsym 'SYM: +human_faces -0.33*food -0.33*objects -0.33*places' -glt_label 2 face-obj_food_place -gltsym 'SYM: -0.33*human_faces -0.33*food -0.33*objects +places' -glt_label 3 place-face_obj_food -gltsym 'SYM: +tf2Hz -tf12Hz' -glt_label 4 tf2Hz-tf12Hz -gltsym 'SYM: -tf2Hz +tf12Hz' -glt_label 5 tf12Hz-tf2Hz -gltsym 'SYM: +LLquad +LRquad +ULquad +URquad +fovea +human_faces +animal_faces +human_bodies +animal_bodies +food +objects +places +noise +tf2Hz +tf12Hz' -glt_label 6 all_vis -gltsym 'SYM: +LeftFinger +LeftToe +RightFinger +RightToe +Tongue' -glt_label 7 all_motor -gltsym 'SYM: +250HzTone +315HzTone +400HzTone +500HzTone +630HzTone +800HzTone +1000HzTone +1250HzTone +1600HzTone +2000HzTone +2500HzTone +3150HzTone +4000HzTone' -glt_label 8 all_audio"

    else if ( ($which_task == 'prf') && ($prf == 1) ) then
        set n_cond = 33 

        set stim_file_reg = "-stim_times 1 "{$regressorDir}"prf1_*_vfLLquad.txt GAM -stim_label 1 LLquad -stim_times 2 "{$regressorDir}"prf1_*_vfLRquad.txt GAM -stim_label 2 LRquad -stim_times 3 "{$regressorDir}"prf1_*_vfULquad.txt GAM -stim_label 3 ULquad -stim_times 4 "{$regressorDir}"prf1_*_vfURquad.txt GAM -stim_label 4 URquad -stim_times 5 "{$regressorDir}"prf1_*_fovea.txt GAM -stim_label 5 fovea -stim_times 6 "{$regressorDir}"prf1_*_left_fingers.txt 'BLOCK4(13,1)' -stim_label 6 LeftFinger -stim_times 7 "{$regressorDir}"prf1_*_left_toes.txt 'BLOCK4(13,1)' -stim_label 7 LeftToe -stim_times 8 "{$regressorDir}"prf1_*_right_fingers.txt 'BLOCK4(13,1)' -stim_label 8 RightFinger -stim_times 9 "{$regressorDir}"prf1_*_right_toes.txt 'BLOCK4(13,1)' -stim_label 9 RightToe -stim_times 10 "{$regressorDir}"prf1_*_tongue.txt 'BLOCK4(13,1)' -stim_label 10 Tongue -stim_times 11 "{$regressorDir}"prf1_*_250HzTone.txt GAM -stim_label 11 250HzTone -stim_times 12 "{$regressorDir}"prf1_*_315HzTone.txt GAM -stim_label 12 315HzTone -stim_times 13 "{$regressorDir}"prf1_*_400HzTone.txt GAM -stim_label 13 400HzTone -stim_times 14 "{$regressorDir}"prf1_*_500HzTone.txt GAM -stim_label 14 500HzTone -stim_times 15 "{$regressorDir}"prf1_*_630HzTone.txt GAM -stim_label 15 630HzTone -stim_times 16 "{$regressorDir}"prf1_*_800HzTone.txt GAM -stim_label 16 800HzTone -stim_times 17 "{$regressorDir}"prf1_*_1000HzTone.txt GAM -stim_label 17 1000HzTone -stim_times 18 "{$regressorDir}"prf1_*_1250HzTone.txt GAM -stim_label 18 1250HzTone -stim_times 19 "{$regressorDir}"prf1_*_1600HzTone.txt GAM -stim_label 19 1600HzTone -stim_times 20 "{$regressorDir}"prf1_*_2000HzTone.txt GAM -stim_label 20 2000HzTone -stim_times 21 "{$regressorDir}"prf1_*_2500HzTone.txt GAM -stim_label 21 2500HzTone -stim_times 22 "{$regressorDir}"prf1_*_3150HzTone.txt GAM -stim_label 22 3150HzTone -stim_times 23 "{$regressorDir}"prf1_*_4000HzTone.txt GAM -stim_label 23 4000HzTone -stim_times 24 "{$regressorDir}"prf1_*_human_faces.txt 'BLOCK4(16, 1)' -stim_label 24 human_faces -stim_times 25 "{$regressorDir}"prf1_*_animal_faces.txt 'BLOCK4(16, 1)' -stim_label 25 animal_faces -stim_times 26 "{$regressorDir}"prf1_*_human_bodies.txt 'BLOCK4(16, 1)' -stim_label 26 human_bodies -stim_times 27 "{$regressorDir}"prf1_*_animal_bodies.txt 'BLOCK4(16, 1)' -stim_label 27 animal_bodies -stim_times 28 "{$regressorDir}"prf1_*_food.txt 'BLOCK4(16, 1)' -stim_label 28 food -stim_times 29 "{$regressorDir}"prf1_*_objects.txt 'BLOCK4(16, 1)' -stim_label 29 objects -stim_times 30 "{$regressorDir}"prf1_*_places.txt 'BLOCK4(16, 1)' -stim_label 30 places -stim_times 31 "{$regressorDir}"prf1_*_noise.txt 'BLOCK4(16, 1)' -stim_label 31 noise -stim_times 32 "{$regressorDir}"prf1_*_2HzVisual.txt 'BLOCK4(16, 1)' -stim_label 32 tf2Hz -stim_times 33 "{$regressorDir}"prf1_*_12HzVisual.txt 'BLOCK4(16, 1)' -stim_label 33 tf12Hz"
        set glt_reg = "-gltsym 'SYM: +0.5*food +0.5*objects -noise' -glt_label 1 obj_food-noise -gltsym 'SYM: +human_faces -0.33*food -0.33*objects -0.33*places' -glt_label 2 face-obj_food_place -gltsym 'SYM: -0.33*human_faces -0.33*food -0.33*objects +places' -glt_label 3 place-face_obj_food -gltsym 'SYM: +tf2Hz -tf12Hz' -glt_label 4 tf2Hz-tf12Hz -gltsym 'SYM: -tf2Hz +tf12Hz' -glt_label 5 tf12Hz-tf2Hz -gltsym 'SYM: +LLquad +LRquad +ULquad +URquad +fovea +human_faces +animal_faces +human_bodies +animal_bodies +food +objects +places +noise +tf2Hz +tf12Hz' -glt_label 6 all_vis -gltsym 'SYM: +LeftFinger +LeftToe +RightFinger +RightToe +Tongue' -glt_label 7 all_motor -gltsym 'SYM: +250HzTone +315HzTone +400HzTone +500HzTone +630HzTone +800HzTone +1000HzTone +1250HzTone +1600HzTone +2000HzTone +2500HzTone +3150HzTone +4000HzTone' -glt_label 8 all_audio"

    else if ($which_task == 'css') then
        foreach css_block ( 'tgt' 'ns10' 'ss10' 'ns20' 'ss20' 'ns40' 'ss40' 'ns80' 'ss80' )
            touch {$regressorDir}all_css_{$css_block}.txt
            foreach css_run ( '0' '1' '2' )
                if ( -f {$regressorDir}css{$css_run}_{$css_block}.txt ) then
                    echo found {$regressorDir}css{$css_run}_{$css_block}.txt, moving on...
                else
                    echo '*' > {$regressorDir}css{$css_run}_{$css_block}.txt
                endif
                cat {$regressorDir}css{$css_run}_{$css_block}.txt >> {$regressorDir}all_css_{$css_block}.txt
            end
        end
        cat {$regressorDir}css*_ns00.txt > {$regressorDir}all_css_ns00.txt
        cat {$regressorDir}css*_ss00.txt > {$regressorDir}all_css_ss00.txt

        set n_cond = 10 

        set stim_file_reg = "-stim_times 1 "{$regressorDir}"all_css_tgt.txt 'BLOCK4(9,1)' -stim_label 1 tgt -stim_times 2 "{$regressorDir}"all_css_ss00.txt 'BLOCK4(9,1)' -stim_label 2 ss00 -stim_times 3 "{$regressorDir}"all_css_ns10.txt 'BLOCK4(9,1)' -stim_label 3 ns10 -stim_times 4 "{$regressorDir}"all_css_ss10.txt 'BLOCK4(9,1)' -stim_label 4 ss10 -stim_times 5 "{$regressorDir}"all_css_ns20.txt 'BLOCK4(9,1)' -stim_label 5 ns20 -stim_times 6 "{$regressorDir}"all_css_ss20.txt 'BLOCK4(9,1)' -stim_label 6 ss20 -stim_times 7 "{$regressorDir}"all_css_ns40.txt 'BLOCK4(9,1)' -stim_label 7 ns40 -stim_times 8 "{$regressorDir}"all_css_ss40.txt 'BLOCK4(9,1)' -stim_label 8 ss40 -stim_times 9 "{$regressorDir}"all_css_ns80.txt 'BLOCK4(9,1)' -stim_label 9 ns80 -stim_times 10 "{$regressorDir}"all_css_ss80.txt 'BLOCK4(9,1)' -stim_label 10 ss80"
        echo '9@0 1 -1 14@0' > tgt_min_ss00.1D 
        set glt_reg = "-glt 1 tgt_min_ss00.1D -glt_label 1 tgt-ss00"

    else if ($which_task == 'cop') then
        touch {$regressorDir}all_cop_tgt.txt
        foreach cop_run ( '1' '2' )
            if ( -f {$regressorDir}cop{$cop_run}_tgt.txt ) then
                echo found {$regressorDir}cop{$cop_run}_tgt.txt, moving on...
            else
                echo '*' > {$regressorDir}cop{$cop_run}_tgt.txt
            endif
            cat {$regressorDir}cop{$cop_run}_tgt.txt >> {$regressorDir}all_cop_tgt.txt
        end

        if ( -f {$regressorDir}all_cop_bg_cont.txt ) then
            rm {$regressorDir}all_cop_bg_cont.txt
        endif
        cat {$regressorDir}cop1_bg_cont.txt > {$regressorDir}all_cop_bg_cont.txt
        echo '' >> {$regressorDir}all_cop_bg_cont.txt
        cat {$regressorDir}cop2_bg_cont.txt >> {$regressorDir}all_cop_bg_cont.txt

        if ( -f {$regressorDir}all_cop_bg_scr.txt ) then
            rm {$regressorDir}all_cop_bg_scr.txt
        endif
        cat {$regressorDir}cop1_bg_scr.txt > {$regressorDir}all_cop_bg_scr.txt
        echo '' >> {$regressorDir}all_cop_bg_scr.txt
        cat {$regressorDir}cop2_bg_scr.txt >> {$regressorDir}all_cop_bg_scr.txt

        if ( -f {$regressorDir}all_cop_nb_cont.txt ) then
            rm {$regressorDir}all_cop_nb_cont.txt
        endif
        cat {$regressorDir}cop1_nb_cont.txt > {$regressorDir}all_cop_nb_cont.txt
        echo '' >> {$regressorDir}all_cop_nb_cont.txt
        cat {$regressorDir}cop2_nb_cont.txt >> {$regressorDir}all_cop_nb_cont.txt

        if ( -f {$regressorDir}all_cop_nb_scr.txt ) then
            rm {$regressorDir}all_cop_nb_scr.txt
        endif
        cat {$regressorDir}cop1_nb_scr.txt > {$regressorDir}all_cop_nb_scr.txt
        echo '' >> {$regressorDir}all_cop_nb_scr.txt
        cat {$regressorDir}cop2_nb_scr.txt >> {$regressorDir}all_cop_nb_scr.txt

        set n_cond = 5

        set stim_file_reg = "-stim_times 1 "{$regressorDir}"all_cop_tgt.txt 'BLOCK4(12,1)' -stim_label 1 tgt -stim_times 2 "{$regressorDir}"all_cop_bg_cont.txt GAM -stim_label 2 bg_cont -stim_times 3 "{$regressorDir}"all_cop_bg_scr.txt GAM -stim_label 3 bg_scr -stim_times 4 "{$regressorDir}"all_cop_nb_cont.txt GAM -stim_label 4 nb_cont -stim_times 5 "{$regressorDir}"all_cop_nb_scr.txt GAM -stim_label 5 nb_scr"
        set glt_reg =""

    endif

    foreach add_me (1 2 3 4 5 6)
        @ num_${add_me} = $add_me + $n_cond
    end
    @ num_ts = $n_cond + 6

# ------------------------------
# run the regression analysis
    echo "3dDeconvolve -input $scale_list"\
        "-censor motion_${subj}_${which_task}_censor.1D "\
        "-polort 'A' -float "\
        "-num_stimts $num_ts "\
        "$stim_file_reg "\
        "-stim_file $num_1 motion_demean_${which_task}.1D'[0]' -stim_base $num_1 -stim_label $num_1 roll "\
        "-stim_file $num_2 motion_demean_${which_task}.1D'[1]' -stim_base $num_2 -stim_label $num_2 pitch "\
        "-stim_file $num_3 motion_demean_${which_task}.1D'[2]' -stim_base $num_3 -stim_label $num_3 yaw "\
        "-stim_file $num_4 motion_demean_${which_task}.1D'[3]' -stim_base $num_4 -stim_label $num_4 dS "\
        "-stim_file $num_5 motion_demean_${which_task}.1D'[4]' -stim_base $num_5 -stim_label $num_5 dL "\
        "-stim_file $num_6 motion_demean_${which_task}.1D'[5]' -stim_base $num_6 -stim_label $num_6 dP "\
        "$glt_reg "\
        "-fout -tout -x1D X.${which_task}.xmat.1D -xjpeg X.${which_task}.jpg "\
        "-x1D_uncensored X.${which_task}.nocensor.xmat.1D "\
        "-fitts fitts.$subj.${which_task} "\
        "-errts errts.${subj}.${which_task} "\
        "-bucket stats.$subj.${which_task} "\
        "-cbucket cbucket.$subj.${which_task} "\
        "-mask full_mask.$subj+orig "\
        "-GOFORIT $n_goforit" > 3dDeconvolve_{$which_task}.csh

    chmod ug+x 3dDeconvolve_{$which_task}.csh

    ./3dDeconvolve_{$which_task}.csh |& tee out_3dDeconvolve_${which_task}.txt

    # -- use 3dTproject to project out regression matrix --
    3dTproject -polort 0 -input $scale_list                                                       \
               -censor motion_${subj}_{$which_task}_censor.1D -cenmode ZERO                      \
               -ort X.{$which_task}.nocensor.xmat.1D -prefix errts.${subj}.{$which_task}.tproject

# if 3dDeconvolve fails, terminate the script
    if ( $status != 0 ) then
        echo '---------------------------------------'
        echo '** 3dDeconvolve error, failing...'
        echo '   (consider the file 3dDeconvolve.err)'
        exit
    endif


# display any large pairwise correlations from the X-matrix
    1d_tool.py -show_cormat_warnings -infile X.{$which_task}.xmat.1D |& tee out.cormat_warn.txt

# create an all_runs dataset to match the fitts, errts, etc.
    3dTcat -prefix all_runs.$subj.{$which_task} $scale_list

# --------------------------------------------------
# create a temporal signal to noise ratio dataset 
#    signal: if 'scale' BLOCK4, mean should be 100
#    noise : compute standard deviation of errts
    3dTstat -overwrite -mean -prefix rm.signal.all all_runs.$subj.{$which_task}+orig"[$ktrs]"
    3dTstat -overwrite -stdev -prefix rm.noise.all errts.${subj}.{$which_task}.tproject+orig"[$ktrs]"
    3dcalc -a rm.signal.all+orig                                                  \
           -b rm.noise.all+orig                                                   \
           -c full_mask.$subj+orig                                                \
           -expr 'c*a/b' -prefix TSNR.$subj.{$which_task} 

# ---------------------------------------------------
# compute and store GCOR (global correlation average)
# (sum of squares of global mean of unit errts)
    3dTnorm -overwrite -norm2 -prefix rm.errts.unit errts.${subj}.{$which_task}.tproject+orig
    3dmaskave -quiet -mask full_mask.$subj+orig rm.errts.unit+orig                          \
              > gmean.errts.unit.{$which_task}.1D
    3dTstat -sos -prefix - gmean.errts.unit.{$which_task}.1D\' > out.gcor.{$which_task}.1D
    echo '-- GCOR = cat out.gcor.'${which_task}'.1D'

# ---------------------------------------------------
# compute correlation volume
# (per voxel: average correlation across masked brain)
# (now just dot product with average unit time series)
    3dcalc -overwrite -a rm.errts.unit+orig -b gmean.errts.unit.{$which_task}.1D \
        -expr 'a*b' -prefix rm.DP
    3dTstat -sum -prefix corr_brain.{$which_task} rm.DP+orig

# --------------------------------------------------------
# compute sum of non-baseline regressors from the X-matrix
# (use 1d_tool.py to get list of regressor colums)
    if ( $which_task == 'prf' ) then
        set reg_cols = `1d_tool.py -infile X.prf.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'css' ) then
        set reg_cols = `1d_tool.py -infile X.css.nocensor.xmat.1D -show_indices_interest`
    else if ( $which_task == 'cop' ) then
        set reg_cols = `1d_tool.py -infile X.cop.nocensor.xmat.1D -show_indices_interest`
    endif
    3dTstat -sum -prefix sum_ideal.{$which_task}.1D X.{$which_task}.nocensor.xmat.1D"[$reg_cols]"

# also, create a stimulus-only X-matrix, for easy review
    1dcat X.{$which_task}.nocensor.xmat.1D"[$reg_cols]" > X.{$which_task}.stim.xmat.1D

# ============================ blur estimation =============================
# compute blur estimates
    touch blur_est.$subj.{$which_task}.1D
    # start with empty file


# -- estimate blur for each run in epits --
    touch blur.epits.{$which_task}.1D

# restrict to uncensored TRs, per run
    foreach run ( $idx_runs )
        if ( $which_task == 'prf' ) then
            set trs = `1d_tool.py -infile X.prf.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'css' ) then
            set trs = `1d_tool.py -infile X.css.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'cop' ) then
            set trs = `1d_tool.py -infile X.cop.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        endif

        if ( $trs == "" ) continue
        3dFWHMx -detrend -mask full_mask.$subj+orig                                     \
                -ACF files_ACF/out.3dFWHMx.ACF.epits{$which_task}.r$run.1D              \
                all_runs.$subj.{$which_task}+orig"[$trs]" >> blur.epits.{$which_task}.1D
    end

# compute average FWHM blur (from every other row) and append
    if ( $which_task == 'prf' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.prf.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'css' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.css.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'cop' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.cop.1D'{0..$(2)}'\'` )
    endif
    echo average epits FWHM blurs: $blurs
    echo "$blurs   # epits FWHM blur estimates" >> blur_est.$subj.{$which_task}.1D

# compute average ACF blur (from every other row) and append
    if ( $which_task == 'prf' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.prf.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'css' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.css.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'cop' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.epits.cop.1D'{1..$(2)}'\'` )
    endif
    echo average epits ACF blurs: $blurs
    echo "$blurs   # epits ACF blur estimates" >> blur_est.$subj.{$which_task}.1D

# -- estimate blur for each run in errts --
    touch blur.errts.{$which_task}.1D

# restrict to uncensored TRs, per run
    foreach run ( $idx_runs )
        if ( $which_task == 'prf' ) then
            set trs = `1d_tool.py -infile X.prf.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'css' ) then
            set trs = `1d_tool.py -infile X.css.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        else if ( $which_task == 'cop' ) then
            set trs = `1d_tool.py -infile X.cop.xmat.1D -show_trs_uncensored encoded -show_trs_run $run`
        endif
        if ( $trs == "" ) continue
        3dFWHMx -detrend -mask full_mask.$subj+orig                                             \
                -ACF files_ACF/out.3dFWHMx.ACF.errts.{$which_task}.r$run.1D                     \
                errts.${subj}.{$which_task}.tproject+orig"[$trs]" >> blur.errts.{$which_task}.1D
    end

# compute average FWHM blur (from every other row) and append
    if ( $which_task == 'prf' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.errts.prf.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'css' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.errts.css.1D'{0..$(2)}'\'` )
    else if ( $which_task == 'cop' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.errts.cop.1D'{0..$(2)}'\'` )
    endif
    echo average errts FWHM blurs: $blurs
    echo "$blurs   # errts FWHM blur estimates" >> blur_est.$subj.{$which_task}.1D

# compute average ACF blur (from every other row) and append
    if ( $which_task == 'prf' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.errts.prf.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'css' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.errts.css.1D'{1..$(2)}'\'` )
    else if ( $which_task == 'cop' ) then
        set blurs = ( `3dTstat -mean -prefix - blur.errts.cop.1D'{1..$(2)}'\'` )
    endif
    echo average errts ACF blurs: $blurs
    echo "$blurs   # errts ACF blur estimates" >> blur_est.$subj.{$which_task}.1D

# add 3dClustSim results as attributes to any stats dset

# run Monte Carlo simulations using method 'ACF'
    set params = ( `grep ACF blur_est.$subj.{$which_task}.1D | tail -n 1` )
    3dClustSim -both -mask full_mask.$subj+orig -acf $params[1-3]            \
               -cmd 3dClustSim.ACF.{$which_task}.cmd -prefix files_ClustSim/ClustSim.ACF.{$which_task}
# run 3drefit to attach 3dClustSim results to stats
    set cmd = ( `cat 3dClustSim.ACF.{$which_task}.cmd` )
    $cmd stats.$subj.{$which_task}+orig


# ================== auto BLOCK4: generate review scripts ===================

    3dcalc -overwrite -prefix corr_brain.{$which_task}+orig -a corr_brain.{$which_task}+orig -expr 'a' -datum short
    3dcalc -overwrite -prefix errts.${subj}.{$which_task}+orig -a errts.${subj}.{$which_task}+orig -expr 'a' -datum short
    3dcalc -overwrite -prefix errts.${subj}.{$which_task}.tproject+orig -a errts.${subj}.{$which_task}.tproject+orig -expr 'a' -datum short
    3dcalc -overwrite -prefix fitts.${subj}.{$which_task}+orig -a fitts.${subj}.{$which_task}+orig -expr 'a' -datum short
    3dcalc -overwrite -prefix TSNR.${subj}.{$which_task}+orig -a TSNR.${subj}.{$which_task}+orig -expr 'a' -datum short


    cp X.{$which_task}.xmat.1D X.xmat.1D # script below is stupid and has hard-coded assumption about this file...

    gen_ss_review_scripts.py -mot_limit 0.5                        \
        -uvar align_anat anat_SurfVol_ns_uni+orig                  \
        -uvar censor_dset motion_${subj}_{$which_task}_censor.1D   \
        -uvar enorm_dset motion_${subj}_{$which_task}_enorm.1D     \
        -uvar errts_dset errts.${subj}.{$which_task}.tproject+orig \
        -uvar final_anat anat_final.{$subj}+orig                   \
        -uvar final_view orig                                      \
        -uvar gcor_dset out.gcor.{$which_task}.1D                  \
        -uvar mask_dset full_mask.{$subj}+orig.HEAD                \
        -uvar motion_dset dfile_{$which_task}.1D                   \
        -uvar num_stim $n_cond                                     \
        -uvar outlier_dset outcount_{$which_task}.1D               \
        -uvar stats_dset stats.{$subj}.{$which_task}+orig          \
        -uvar subj {$subj}                                         \
        -uvar sum_ideal sum_ideal.{$which_task}.1D                 \
        -uvar tcat_dset pb00.{$subj}.r01.tcat+orig                 \
        -uvar tsnr_dset TSNR.{$subj}.{$which_task}+orig            \
        -uvar volreg_dset pb02.{$subj}.r01.volreg+orig.HEAD        \
        -xmat_regress X.{$which_task}.xmat.1D                      \
        -xmat_uncensored X.{$which_task}.nocensor.xmat.1D          \
        -prefix {$which_task}                                      \
        -exit0

    # if the basic subject review script is here, run it
    # (want this to be the last text output)
    if ( -e {$which_task}@ss_review_basic ) then
        echo "executing $which_task@ss_review_basic"
        ./{$which_task}@ss_review_basic |& tee out.ss_review.$subj.{$which_task}.txt
    else
        echo "did not find $which_task@ss_review_basic"
    endif

    rm X.xmat.1D # clean this up

# ========================== auto BLOCK4: finalize ==========================
end

# generate a review script for the unprocessed EPI data
gen_epi_review.py -script @epi_review.$subj \
    -dsets pb00.$subj.r*.tcat+orig.HEAD

# remove temporary files
\rm -f rm.*


# return to parent directory
cd ..

echo "execution finished: `date`"




# ==========================================================================
# script generated by the command:
#
# afni_proc.py